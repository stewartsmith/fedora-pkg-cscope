diff -rU4 -N cscope-15.5/src/constants.h cscope-15.5-findassign/src/constants.h
--- cscope-15.5/src/constants.h	2003-09-04 11:54:02.000000000 -0400
+++ cscope-15.5-findassign/src/constants.h	2004-07-01 21:37:42.000000000 -0400
@@ -92,9 +92,9 @@
 #define	CHANGE		5
 #define	REGEXP		6
 #define FILENAME	7
 #define INCLUDES	8
-#define	FIELDS		9
+#define	FIELDS		11
 
 #if (BSD || V9) && !__NetBSD__
 #define TERMINFO	0	/* no terminfo curses */
 #else
diff -rU4 -N cscope-15.5/src/display.c cscope-15.5-findassign/src/display.c
--- cscope-15.5/src/display.c	2003-09-04 11:54:02.000000000 -0400
+++ cscope-15.5-findassign/src/display.c	2004-07-01 21:06:47.000000000 -0400
@@ -104,8 +104,9 @@
 	{"Find this", "egrep pattern",			findregexp},
 	{"Find this", "file",				findfile},
 	{"Find", "files #including this file",		findinclude},
 	{"Find all", "function definitions",		findallfcns},	/* samuel only */
+	{"Find all", "symbol assignments",		findassign},
 };
 
 /* Internal prototypes: */
 static	RETSIGTYPE	jumpback(int sig);
diff -rU4 -N cscope-15.5/src/find.c cscope-15.5-findassign/src/find.c
--- cscope-15.5/src/find.c	2003-09-04 11:58:52.000000000 -0400
+++ cscope-15.5-findassign/src/find.c	2004-07-01 22:10:31.000000000 -0400
@@ -76,8 +76,10 @@
 static	char	*lcasify(char *s);
 static	void	findcalledbysub(char *file, BOOL macro);
 static	void	findterm(char *pattern);
 static	void	putline(FILE *output);
+static  char    *find_symbol_or_assignment(char *pattern, BOOL assign_flag);
+static  BOOL    check_for_assignment(void);
 static	void	putpostingref(POSTING *p, char *pat);
 static	void	putref(int seemore, char *file, char *func);
 static	void	putsource(int seemore, FILE *output);
 
@@ -85,8 +87,79 @@
 
 char *
 findsymbol(char *pattern)
 {
+	return find_symbol_or_assignment(pattern, NO);
+}
+
+/* find the symbol in the cross-reference, and look for assignments */
+char *
+findassign(char *pattern)
+{
+	return find_symbol_or_assignment(pattern, YES);
+}
+
+/* Test reference whether it's an assignment to the symbol found at
+ * (global variable) 'blockp' */
+static BOOL
+check_for_assignment(void) 
+{
+	/* Do the extra work here to determine if this is an
+	* assignment or not Do this by examining the next character
+	* or two in blockp */
+	char *asgn_char = blockp;
+	int i = 1; /*skip any leading \n*/
+
+	while(1) {
+		if (asgn_char[i] == blockmark) {
+			/* get the next block when we reach the end of
+			* the current block */
+			asgn_char = readblock();
+			i=0;
+		}
+		while (isspace((unsigned char) asgn_char[i])) {
+			/* skip any whitespace or \n */
+			i++;
+		}
+		/* this next character better be one of the assignment
+		* characters, ie: =, +=, -=, *=, %=, /=, &=, |=, ^=,
+		* ~= if not, then its a notmatched case */
+		if ((asgn_char[i] != '=') &&
+		   (asgn_char[i] != '+') && 
+		   (asgn_char[i] != '-') && 
+		   (asgn_char[i] != '*') && 
+		   (asgn_char[i] != '/') && 
+		   (asgn_char[i] != '%') && 
+		   (asgn_char[i] != '&') && 
+		   (asgn_char[i] != '|') && 
+		   (asgn_char[i] != '^') && 
+		   (asgn_char[i] != '~')) {
+			return NO;
+		} else {
+			/* if the first found character is = and the
+			* next found character is also =, then this
+			* is not an assignment.  likewise if the
+			* first character is not = (i.e. one of the
+			* +,-,*,etc. chars and the next character is
+			* not =, then this is not an assignment */
+			if ((((asgn_char[i] == '=')
+			     && (asgn_char[i+1] == '='))) 
+			   || ((asgn_char[i] != '=')
+				&& (asgn_char[i+1] != '='))) {
+				return NO;
+			}
+			/* if we pass all these filters then this is
+			* an assignment */
+			return YES;
+		} /* else(operator char?) */
+	} /* while(endless) */
+}
+
+/* The actual routine that does the work for findsymbol() and
+* findassign() */
+static char *
+find_symbol_or_assignment(char *pattern, BOOL assign_flag)
+{
 	char	file[PATHLEN + 1];	/* source file name */
 	char	function[PATLEN + 1];	/* function name */
 	char	macro[PATLEN + 1];	/* macro name */
 	char	symbol[PATLEN + 1];	/* symbol name */
@@ -242,8 +315,16 @@
 			/* match the rest of the symbol to the text pattern */
 			if (matchrest()) {
 				s = NULL;
 		matched:
+				/* if the assignment flag is set then
+				 * we are looking for assignments and
+				 * some extra filtering is needed */
+				if(assign_flag == YES
+				  && ! check_for_assignment())
+				       goto notmatched;
+
+
 				/* output the file, function or macro, and source line */
 				if (strcmp(macro, global) && s != macro) {
 					putref(0, file, macro);
 				}
diff -rU4 -N cscope-15.5/src/global.h cscope-15.5-findassign/src/global.h
--- cscope-15.5/src/global.h	2003-09-04 11:54:03.000000000 -0400
+++ cscope-15.5-findassign/src/global.h	2004-07-01 21:19:24.000000000 -0400
@@ -318,8 +318,9 @@
 char	*finddef(char *pattern);
 char	*findfile(char *dummy);
 char	*findinclude(char *pattern);
 char	*findsymbol(char *pattern);
+char	*findassign(char *pattern);
 char	*findregexp(char *egreppat);
 char	*findstring(char *pattern);
 char	*inviewpath(char *file);
 char	*lookup(char *ident);
